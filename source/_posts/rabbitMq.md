title: RabbitMQ 知识点总结
author: Laiyong Wang
date: 2025-06-16 22:33:37
tags:
---
### 安装
参考另一片文章 服务器安装 rabbitMQ 及使用方法: <http://laiyong.wang/2022/09/04/rabbitmqInstall/>

### rabbitMQ的整体架构

![upload successful](/images/pasted-56.png)
- Producer（生产者）：生产者是消息的发送方，负责将消息发布到RabbitMQ的交换器（Exchange）。

- VHost：是RabbitMQ中虚拟主机的概念，它类似于操作系统中的命名空间，用于将RabbitMQ的资源进行隔离和分组。每个VHost拥有自己的交换器、队列、绑定和权限设置，不同VHost之间的资源相互独立，互不干扰。VHost可以用于将不同的应用或服务进行隔离，以防止彼此之间的消息冲突和资源竞争。

- Exchange（交换器）：交换器是消息的接收和路由中心，它接收来自生产者的消息，并将消息路由到一个或多个与之绑定的队列（Queue）中。

- Queue（队列）：队列是消息的存储和消费地，它保存着未被消费的消息，等待消费者（Consumer）从队列中获取并处理消息。

- Binding（绑定）：绑定是交换器和队列之间的关联关系，它定义了交换器将消息路由到哪些队列中。

- Consumer（消费者）：消费者是消息的接收方，负责从队列中获取消息，并进行处理和消费。

### rabbitMQ的消息分发
具体实现可以参考：https://www.rabbitmq.com/getstarted.html
- 简单模式
一个生产者将消息发送到一个队列中，一个消费者从队列中获取并处理消息。这种模式适用于单个生产者和单个消费者的简单场景，消息的处理是同步的。

![upload successful](/images/pasted-58.png)

- 工作模式
一个生产者将消息发送到一个队列中，多个消费者从队列中获取并处理消息。每个消息只能被一个消费者处理。这种模式适用于多个消费者并发处理消息的情况，提高了系统的处理能力和吞吐量

![upload successful](/images/pasted-59.png)

- 发布/订阅模式
一个生产者将消息发送到交换器（Exchange）中，交换器将消息广播到所有绑定的队列，每个队列对应一个消费者。这种模式适用于消息需要被多个消费者同时接收和处理的广播场景，如日志订阅和事件通知等。

![upload successful](/images/pasted-60.png)
- 路由模式
一个生产者将消息发送到交换器中，并指定消息的路由键，交换器根据路由键将消息路由到与之匹配的队列中。这种模式适用于根据不同的条件将消息发送到不同的队列中，以实现消息的筛选和分发

![upload successful](/images/pasted-61.png)
- 主题模式
一个生产者将消息发送到交换器中，并指定主题（Topic）作为路由键，交换器根据通配符匹配将消息路由到与之匹配的队列中。这种模式适用于消息的复杂路由需求，可以实现高度灵活的消息筛选和分发。

![upload successful](/images/pasted-63.png)

### RabbitMQ的死信队列
死信队列（Dead Letter Queue）是一种用于处理消息处理失败或无法路由的消息的机制。它允许将无法被正常消费的消息重新路由到另一个队列，以便稍后进行进一步的处理、分析或排查问题
- 死信
 - 消息处理失败：当消费者由于代码错误、消息格式不正确、业务规则冲突等原因无法成功处理一条消息时，这条消息可以被标记为死信。
 - 消息过期：在RabbitMQ中，消息可以设置过期时间。如果消息在规定的时间内没有被消费，它可以被认为是死信并被发送到死信队列。
 - 消息被拒绝：当消费者明确拒绝一条消息时，它可以被标记为死信并发送到死信队列。拒绝消息的原因可能是消息无法处理，或者消费者认为消息不符合处理条件。
 - 消息无法路由：当消息不能被路由到任何队列时，例如，没有匹配的绑定关系或路由键时，消息可以被发送到死信队列。
 
### 延迟消息
- 基于死信队列，给消息设置过期时间
问题 ： 队头阻塞。RabbitMQ会定期扫描队列的头部，检查队首的消息是否过期。如果队首消息过期了，它会被放到死信队列中。但是RabbitMQ不会逐个检查队列中的所有消息是否过期，而是仅检查队首消息。这样，如果队列的队头消息未过期，而它后面的消息已过期，这些后续消息将无法被单独移除，直到队头的消息被消费或过期

- rabbitmq_delayed_message_exchange 插件
 - 死信队列的方式：消息先会投递到一个正常队列，在TTL过期后进入死信队列。
 - 插件的方式：消息并不会立即进入队列，而是先把他们保存在一个基于Erlang开发的Mnesia数据库中，然后通过一个定时器去查询需要被投递的消息，再把他们投递到x-delayed-message交换机中。
### RabbitMQ 如何保证高可用
- 普通集群模式
- 镜像模式
### RabbitMQ实现消费端限流
把自动提交关闭
### RabbitMQ如何防止重复消费
RabbitMQ有确认机制，正常情况下，消费者在消息消费成功后，会发送一个确认消息，消息队列接收到之后，就会将该消息从消息队列中删除
但是有网络延迟的情况，消费者也需要做好幂等控制来防止消息被重复消费

### 如何保障消息一定能发送到RabbitMQ
生产者->交换机->队列：两个过程都可能丢
confirm机制
- Publisher Confirm 机制，用于确保消息已经被Exchange成功接收和处理
- Publisher Returns 机制，用于处理在消息无法路由到任何队列时的情况。当RabbitMQ在无法路由消息时将消息返回给消息生产者，但是如果能正确路由，则不会返回消息

### RabbitMQ如何保证消息不丢
- 队列持久化
声明队列时，设置durable参数为true
- 交换机持久化
声明交换机时，设置durable参数为true
- 持久化绑定
队列和交换机相关联。创建绑定关系时，设置durable参数为true
- 持久化消息
生产者发送的消息可以通过设置消息的deliveryMode为2来创建持久化消息
- 消费者确认机制
消费者处理消息成功后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息，这样才能确保消息不会丢失。如果消费者在处理消息中出现了异常，那么就会返回nack回执，MQ收到回执之后就会重新投递一次消息，如果消费者一直都没有返回ACK/NACK的话，那么他也会在尝试重新投递

- 无法做到100%不丢
因为MQ的持久化过程其实是异步的。即使我们开了持久化，也有可能在内存暂存成功后，异步持久化之前宕机，那么消息就会丢失。